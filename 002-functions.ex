@doc """
    Функции в эликсире, на первый взгляд, похожи на функции обычных императивных языков. 
    Но это только на первый. Как вы увидите дальше, они во многом устроены по другому, 
    что сильно влияет на способ организации кода внутри них.

    Самый простой способ определить функцию – использовать конструкцию def/do/end:
"""
def hello do
  IO.puts("Hello, World!")
end

@doc """
    Если функция не принимает аргументов, то при ее определении можно не указывать скобок.

    Если функция принимает параметры, то они указываются в определении, так же как и в 
    большинстве других языков:
"""
defmodule Math do
  # Имя записывается в snake_case
  def sum_of_values(a, b) do
    # Обычное сложение
    a + b
  end
end

# Функция может вызываться без скобок!
IO.puts Math.sum_of_values(5, 8) # => 13

@doc """
    В Эликсире нет инструкции return, которая могла бы прервать выполнение кода. Результатом выполнения 
    функции всегда является значение последнего вычисленного выражения. Если функция пустая, 
    то возвращается nil, который аналогичен null в других языках.

    Другая особенность, функции можно вызывать без скобок. Раньше такой синтаксис был популярным, 
    но сейчас не принято так делать. Во вложенных вызовах такая запись становится не очевидной: 
    IO.puts inspect "huh".

    Для коротких функций, состоящих из одного выражения, Эликсир поддерживает специальный, 
    сокращенный синтаксис объявления:
"""
# Обратите внимание на запятую после описания сигнатуры функции и отсутствие end в конце
def sum_of_values(a, b), do: a + b

# или

def hello, do: IO.puts("Hello, World!")

@doc """
    Функции определяемые с помощью def доступны для вызова снаружи модуля. Но не все функции 
    создаваемые внутри модуля, создаются для вызовов снаружи. Иногда функции выполняют 
    вспомогательную роль для других функций этого же модуля. В такой ситуации лучше 
    определять функцию через defp. Эта конструкция делает функцию приватной, 
    то есть ее становится невозможно вызвать за пределами текущего модуля.
"""
defmodule Solution do
  # К функциям из того же модуля можно обращаться без указания модуля
  def hello, do: IO.puts(text_for_hello())

  defp text_for_hello, do: "Hello, World"
end

###### ASSIGNMENT ######
# Реализуйте функцию print_twice(value), которая печатает на экран переданное значение два раза
defmodule Solution do
    def print_twice(str) do
        IO.puts(str)
        IO.puts(str)
    end
end